# Завдання 1: Однозв'язний список

## Опис завдання

Реалізовано однозв'язний список з наступними функціями:
1. **Реверсування списку** - зміна посилань між вузлами
2. **Сортування** - два алгоритми: сортування вставками та сортування злиттям
3. **Об'єднання відсортованих списків** - створення нового відсортованого списку

## Класи та методи

### Клас Node
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```
Представляє вузол списку з даними та посиланням на наступний вузол.

### Клас LinkedList

#### Основні методи:
- `append(data)` - додає новий вузол в кінець списку
- `print_list()` - виводить список на екран
- `reverse()` - реверсує список
- `insertion_sort()` - сортує список вставками
- `merge_sort()` - сортує список злиттям
- `merge_sorted_lists(list1, list2)` - об'єднує два відсортовані списки

## Алгоритми

### 1. Реверсування списку
**Складність:** O(n) за часом

Алгоритм використовує три вказівники:
- `prev` - попередній вузол
- `current` - поточний вузол  
- `next_node` - наступний вузол

На кожній ітерації:
1. Зберігаємо наступний вузол
2. Змінюємо посилання поточного вузла на попередній
3. Переміщуємо вказівники вперед

### 2. Сортування вставками
**Складність:** O(n²) за часом

Алгоритм будує відсортований список поступово:
1. Беремо кожен елемент з невідсортованої частини
2. Вставляємо його в правильну позицію у відсортованій частині
3. Повторюємо для всіх елементів

### 3. Сортування злиттям
**Складність:** O(n log n) за часом

Рекурсивний алгоритм:
1. Розділяємо список на дві половини
2. Рекурсивно сортуємо кожну половину
3. Об'єднуємо відсортовані половини

### 4. Об'єднання відсортованих списків
**Складність:** O(n + m) за часом

Алгоритм порівнює елементи з обох списків і додає менший у результат:
1. Порівнюємо поточні елементи обох списків
2. Додаємо менший елемент у результат
3. Переміщуємо вказівник у відповідному списку
4. Повторюємо до кінця одного зі списків
5. Додаємо залишкові елементи